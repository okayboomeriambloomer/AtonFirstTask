# AtonFirstTask

С первого взгляда всё показалось очень просто: бери словарь да делай хранение по ключу, но потом я вчитался и с досадой осознал, что поиск надо производить по любому полю..  
Но досада продолжалась недолго, просто пришлось ещё подумать)  
Ниже речь пойдёт о методах в классе PersonDAO, я мог бы сделать ещё слой сервиса и наплодить в 2 раза больше методов, но в рамках задачи это дело опустил. Важность сервисного слоя я понимаю. Тут слегка схалтурил, но во благо ясности.  
Я реализовал in-memory БД через 3 словаря. Загвоздка заключалась в том, что до конца неясно как быть с дубликатами. В рамках задания поле account — это какой-то уникальный идентификатор и повторяться он не может. Отлично, с ним проблем не будет. Но как быть с полями name и value? Итак, что в итоге:  
 1й словарь - ключом типа long является account, значением является объект Person.  
 2й словарь - ключом типа String является name, значением же является лист объектов типа Person. Это позволит собрать всех тёсок под ключом с их именем.  
 3й словарь - аналогично второму, но ключом типа double является value.  

При добавлении новой записи, она одновременно помещается во все три словаря в зависимости от своих полей. При удалении объект удаляется из всех трёх словарей. А вот с обновлением получилось некрасиво конечно..  
Дело в том, что изначально я лелеял мысль взять объект(а точнее его значение account), который нужно обновить, достать его из самого первого словаря, который по аккаунту, поменять в нём все поля, которые пользователь захотел поменять и о чудо, в остальных двух словарях этот объект также изменился. Но чудо не случилось. Точнее случилось, но не до конца. Ключ-то в двух оставшихся словарях не поменялся. В общем излил душу читающему - спасибо.  
По итогу обновление пришлось реализовывать сначала удалением из словарей объекта, который хотим поменять, а потом сразу же добавить в словари новый обновленный объект.  
Кстати, отдельно скажу про поле account. Оно редактированию и инициализации со стороны пользователя не поддается. В тз указано осуществлять поиск по всем полям, но в остальном я решил оставить поле account сугубо внутренним. Это создаст опору при поиске записи, когда его захотят изменить. Поле account присуждается новым записям от 0 и до максимального размера int в Java. Просто возвращаемое значение метода size() у словаря имеет тип int. Я понимаю, что в тз у account указан тип long, но решил сузить числовой интервал раз словарь всё равно больше инта хранить не может. Дико извиняюсь за это. При удалении записи, с другими значениями account ничего не происходит, присваивание идёт циклично и если какой-то номер занят, то новой записи присвоится следующий за ним номер или следующий за ним номер или следующий ну в общем понятно. Правда если количество записей достигнет максимума, то приложение никак об это не оповестит, оно просто не добавит новую запись. Это такая бага.. или фича.  

Последнее, о чём хочу написать это результат поиска по полям. В случае поиска по аккаунту особо выдумывать не приходится, каждому значению аккаунта соответствует своя запись. Но в случае с именами или значениями я решил выдавать листы с записями. А пользователь пусть сам решит, кто конкретно ему нужен.  
Также признаюсь, что проверка на валидность не сделана. При добавлении можно ввести пустые значения для новой записи, но в случае со значением это вызовет ошибку на уровне контроллера, так как затайпкастить пустую строку к даблу не выйдет, зато пустое имя корректно отработает, получается такой вот склад безымянных. Их кстати можно удалить.  
На уровне представления и контроллера используются get, post, patch и delete запросы и рассовываются по нужным методам контроллера. Подробно про них говорить наверно нет смысла, большую часть выполняет Spring под капотом, да и моё полотно текста уже великовато. В слое представления использовал Thymeleaf, в принципе всё. Подробнее могу в устной форме рассказать)  

А, и самое главное! Затраты по времени получаются:  
На добавление записи – O(1).  
На удаление и обновление – O(1) в лучшем случае и O(N) в худшем случае. Худший случай возникнет, если все записи будут иметь одинаковое имя или одинаковое значение. Придётся идти по всему листу.  
Поиск записи – O(1). Даже если все поля будут одинаковые, приложение вернет лист с записями за постоянное время.  
Памяти будет задействовано O(3N) из-за трёх словарей, но так как в О-нотации постоянные убираются доп. памяти будет O(N).  
